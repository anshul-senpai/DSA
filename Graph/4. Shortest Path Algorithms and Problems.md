# Shortest Path in UG with unit weights

```c++
class Solution {
  public:
    vector<int> shortestPath(vector<vector<int>>& edges, int N,int M, int src){
        
        vector<vector<int>>adj(N);
        queue<pair<int,int>>q;
        vector<int>vis(N,-1);
        vector<int>ans(N,-1);
        
        for(int i=0;i<M;i++){
            int a = edges[i][0];
            int b = edges[i][1];
            
            adj[a].push_back(b);
            adj[b].push_back(a);
        }
        
        q.push({src,0});
        vis[src] = 1;
        
        while(!q.empty()){
            int i = q.front().first;
            int d = q.front().second;
            q.pop();
            ans[i] = d;
            
            for(int x:adj[i]){
                if(vis[x]==-1){
                    vis[x] = 1;
                    q.push({x,d+1});
                }
            }
        }
        
        return ans;
    }
};
```

- Time Complexity: O(M) { for creating the adjacency list from given list ‘edges’} + O(N + 2M) { for the BFS Algorithm} + O(N) { for adding the final values of the shortest path in the resultant array} ~ O(N+2M). 

    Where N= number of vertices and M= number of edges.

- Space Complexity:  O( N) {for the stack storing the BFS} + O(N) {for the resultant array} + O(N) {for the dist array storing updated shortest paths} + O( N+2M) {for the adjacency list} ~ O(N+M) .

    Where N= number of vertices and M= number of edges.