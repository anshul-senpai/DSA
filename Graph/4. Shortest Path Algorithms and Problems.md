# Shortest Path in UG with unit weights

```c++
class Solution {
  public:
    vector<int> shortestPath(vector<vector<int>>& edges, int N,int M, int src){
        
        vector<vector<int>>adj(N);
        queue<pair<int,int>>q;
        vector<int>vis(N,-1);
        vector<int>ans(N,-1);
        
        for(int i=0;i<M;i++){
            int a = edges[i][0];
            int b = edges[i][1];
            
            adj[a].push_back(b);
            adj[b].push_back(a);
        }
        
        q.push({src,0});
        vis[src] = 1;
        
        while(!q.empty()){
            int i = q.front().first;
            int d = q.front().second;
            q.pop();
            ans[i] = d;
            
            for(int x:adj[i]){
                if(vis[x]==-1){
                    vis[x] = 1;
                    q.push({x,d+1});
                }
            }
        }
        
        return ans;
    }
};
```

- Time Complexity: O(M) { for creating the adjacency list from given list ‘edges’} + O(N + 2M) { for the BFS Algorithm} + O(N) { for adding the final values of the shortest path in the resultant array} ~ O(N+2M). 

    Where N= number of vertices and M= number of edges.

- Space Complexity:  O( N) {for the stack storing the BFS} + O(N) {for the resultant array} + O(N) {for the dist array storing updated shortest paths} + O( N+2M) {for the adjacency list} ~ O(N+M) .

    Where N= number of vertices and M= number of edges.

# Shortest Path in DAG

## Using BFS

```c++
class Solution {
  public:
    vector<int> shortestPath(int N,int M, vector<vector<int>>& edges){
        
        vector<vector<pair<int,int>>>adj(N);
        queue<int>q;
        vector<int>dist(N,1e7);
        
        for(int i=0;i<edges.size();i++){
            int a = edges[i][0];
            int b = edges[i][1];
            int c = edges[i][2];
            
            adj[a].push_back({b,c});
        }
        
        q.push(0);
        dist[0] = 0;
        
        while(!q.empty()){
            int i = q.front();
            q.pop();
            
            for(auto x:adj[i]){
                int a = x.first;
                int b = x.second;
                if(b+dist[i]<dist[a]){
                    q.push(a);
                    dist[a] = b+dist[i];
                }
            }
        }
        
        int n = N;
        vector<int>ans(n,0);
        
        for(int i=0;i<N;i++){
            if(dist[i]!=1e7)
                ans[i] = dist[i];
            else 
                ans[i] = -1;
        }
        
        return ans;
        
    }
};
```

## Using DFS

```c++
class Solution {
  public:
  
    void toposort(int i,vector<int>&vis,vector<vector<pair<int,int>>>&adj,stack<int>&st){
        vis[i] = 1;
        
        for(auto x:adj[i]){
            int a = x.first;
            if(vis[a]==0){
                toposort(a,vis,adj,st);
            }
        }
        
        st.push(i);
    }
  
    vector<int> shortestPath(int N,int M, vector<vector<int>>& edges){
        vector<vector<pair<int,int>>>adj(N);
        vector<int>vis(N,0);
        vector<int>dist(N,1e7);
        vector<int>ans(N,-1);
        stack<int>st;
        
        for(int i=0;i<M;i++){
            int a = edges[i][0];
            int b = edges[i][1];
            int c = edges[i][2];
            
            adj[a].push_back({b,c});
        }
        
        for(int i=0;i<N;i++){
            if(vis[i]==0){
                toposort(i,vis,adj,st);
            }
        }
        
        dist[0] = 0;
        while(!st.empty()){
            int i = st.top();
            st.pop();
            
            for(auto x:adj[i]){
                int a = x.first;
                int d = x.second;
                
                if(dist[i]+d<dist[a]){
                    dist[a] = dist[i]+d;
                }
            }
            
        }
        
        for(int i=0;i<N;i++){
            if(dist[i]!=1e7)
                ans[i] = dist[i];
        }
            
        return ans;
    }
};
```

- Time Complexity: O(N+M) {for the topological sort} + O(N+M) {for relaxation of vertices, each node and its adjacent nodes get traversed} ~ O(N+M).

    Where N= number of vertices and M= number of edges.

- Space Complexity:  O( N) {for the stack storing the topological sort} + O(N) {for storing the shortest distance for each node} + O(N) {for the visited array} + O( N+2M) {for the adjacency list} ~ O(N+M) .

    Where N= number of vertices and M= number of edges.

# Dijkstra's Algorithm

## Using Priority Queue

```c++
class Solution
{
	public:
    vector <int> dijkstra(int V, vector<vector<int>> adj[], int S)
    {
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
        vector<int>dist(V,1e7);
        
        pq.push({0,S});
        dist[S] = 0;
        
        while(!pq.empty()){
            int d = pq.top().first;
            int n = pq.top().second;
            
            pq.pop();
            
            for(auto i:adj[n]){
                int x = i[0];
                int y = i[1];
                
                if(d+y<dist[x]){
                    dist[x] = d+y;
                    pq.push({d+y,x});
                }
            }
        }

        return dist;        
    }
};
```

## Using Set

```c++
class Solution
{
	public:
    vector <int> dijkstra(int V, vector<vector<int>> adj[], int S)
    {
        set<pair<int,int>>s;
        vector<int>dist(V,1e7);
        
        s.insert({0,S});
        dist[S] = 0;
        
        while(!s.empty()){
            auto it = *(s.begin());
            int n = it.second;
            int d = it.first;
            s.erase({d,n});
            
            for(auto x: adj[n]){
                int a = x[0];
                int b = x[1];
                
                if(d+b<dist[a]){
                    if(dist[a]==1e7){
                        s.erase({dist[a],a});
                    }
                    dist[a] = d+b;
                    s.insert({d+b,a});
                }
            }
        }
        
        return dist;
    }
};
```

- `Time Complexity:` `O( E log(V) )`, Where E = Number of edges and V = Number of Nodes.

- `Space Complexity:` `O( |E| + |V| )`, Where E = Number of edges and V = Number of Nodes.

# Print Shortest Path

```c++
class Solution {
  public:
    vector<int> shortestPath(int n, int m, vector<vector<int>>& edges) {
        
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;
        vector<int>dist(n,1e7);
        vector<vector<pair<int,int>>>adj(n);
        vector<int>parent(n,-1);
        vector<int>ans;
        
        for(int i=0;i<m;i++){
            int a = edges[i][0];
            int b = edges[i][1];
            int c = edges[i][2];
            
            adj[a-1].push_back({b-1,c});
            adj[b-1].push_back({a-1,c});
        }
        
        pq.push({0,0});
        dist[0] = 0;
        
        while(!pq.empty()){
            auto it = pq.top();
            int n = it.second;
            int d = it.first;
            pq.pop();
            
            for(auto x:adj[n]){
                int a = x.first;
                int b = x.second;
                
                if(b+d<dist[a]){
                    dist[a] = b+d;
                    pq.push({b+d,a});
                    parent[a] = n;
                }
            }
        }
        
        
        
        int i = n-1;
        if(parent[i]==-1){
            ans.push_back(-1);
            return ans;
        }
        
        ans.push_back(n);
        while(parent[i]!=-1){
            ans.push_back(parent[i]+1);
            i = parent[i];
        }
        
        ans.push_back(dist[n-1]);

        reverse(ans.begin(),ans.end());
        return ans;
    } 
};
```

- `Time and Space Complexity:` Same as Dijkstra's Algorithm.
    