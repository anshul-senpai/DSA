# Rotten Oranges

```c++
int orangesRotting(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    queue<pair<int,int>>q;
    int tot = 0;
    int cnt = 0;
    int day = 0;

    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(grid[i][j]!=0)
                tot++;
            if(grid[i][j]==2)
                q.push({i,j});
        }
    }
    
    int dx[4] = {0,0,-1,1};
    int dy[4] = {1,-1,0,0};

    while(!q.empty()){
        int k = q.size();
        cnt += k;
        for(int i=0;i<k;i++){
            int a = q.front().first;
            int b = q.front().second;
            q.pop();

            for(int j=0;j<4;j++){
                int x = a+dx[j];
                int y = b+dy[j];

                if(x>=0 && x<n && y>=0 && y<m && grid[x][y]==1){
                    grid[x][y] = 2;
                    q.push({x,y});
                }
            }
        }

        if(!q.empty())
            day++;
    }
    
    if(cnt==tot)    
        return day;
    
    return -1;
}
```

- `Time Complexity:` `O ( n x n ) x 4`, Worst-case - We will be making each fresh orange rotten in the grid and for each rotten orange will check in 4 directions
- `Space Complexity:` `O ( n x n )`, Worst-case -  If all oranges are Rotten, we will end up pushing all rotten oranges into the Queue data structure  